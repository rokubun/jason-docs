{"config":{"lang":[""],"separator":"","pipeline":[]},"docs":[{"location":"","title":"Welcome to Jason documentation","text":"<p>Jason is Rokubun's Cloud PPK Service, a cloud service that compute the position of a receiver using the raw GNSS measurements.</p> <p>Jason works on a best-effort basis: it will attempt to compute the best possible solution using a differential technique known as Post-processing Kinematic (PPK), which is the post-processing version of the Real Time Kinematics (RTK). These techniques combine GNSS measurements from nearby reference stations with those of the rover being positioned to cancel out most of the common errors  (ionosphere, troposphere, ...). By nearby it is usually considered less than 50km apart. Depending on the input format you provide, centimetric accuracies  can be achieved.</p> <p>You do not have a reference station? Worry not! we have you covered, Jason will automatically look for a suitable reference station (CORS), among the ones regularly monitored by the service, and use it to try to achieve the best possible accuracy for your data.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Ease of use, drag and drop GNSS files </li> <li>Process various input formats (RINEX, ublox, Septentrio, Android GNSS Logger, ...)</li> <li>Georeference time (e.g. camera trigger) events, which is relevant for the photogrammetry use case</li> <li>Differential positioning for greater accuracy without the need to deploy a   base station, Jason will automatically search/fetch/use the closest base station among   the database of more than 7000 stations tracked by our servers</li> <li>Application Programming Interface (API) to automate your   GNSS data processing workflow. You can include it in your application pipeline   without the need to go through the front-end.</li> <li>Data conversion service for Argonaut/Medea owners: generate Rinex file, IMU   data and time trigger (cam) events from a binary file logged by the receiver.</li> </ul>"},{"location":"#use-cases","title":"Use cases","text":"<p>Jason aims at providing a platform of various potential services and use cases that share the same common need: accurate navigation. Examples of such services and applications follow:</p>"},{"location":"#photogrammetry","title":"Photogrammetry","text":"<p>Jason was created with the photogrammetry workflow in mind: a drone logs both raw GNSS data as well as triggers several photographs, whose time tags are also logged by the receiver (Argonaut supports that as well as the NEO-M8T and ZED-F9P chipsets from ublox). The operator does not worry about base station because he has previously ensured that the campaign area is under Jason coverage.</p> <p>Once the campaign is over, the operator uploads the data to our service, which will automatically find the closest base station available and compute both the navigation solution (ideally using PPK) as well as georeference any time (camera) event present in the input file. This data can be later used in  further steps of the processing.</p> <p></p> <p>This use case is the one covered in the quick start of the manual</p>"},{"location":"#end-to-end-ppk","title":"End-to-end PPK","text":"<p>This use case is similar to the previous case (an operator that performs  a data campaign where GNSS raw measurements can be logged for later processing), but outside the coverage of Jason. In this case the operator provides her own base station that is active during the campaign, also logging GNSS raw measurements.</p> <p>This data is then uploaded in the service, as describe in this example.</p> <p></p>"},{"location":"#coverage","title":"Coverage","text":"<p>The data from the reference stations come from a set of world-wide public providers such as International GNSS Service or EUREF as well as smaller national and regional networks such as the Institut Cartogr\u00e0fic i Geol\u00f2gic de Catalunya and the like.</p> <p>In total, we continuously monitor the availability of more than 7000 CORS stations distributed worldwide. Some areas are better covered than others but unfortunately we cannot provide global coverage.</p> <p></p>"},{"location":"accuracy/","title":"Accuracy analysis","text":"<p>This section includes an accuracy analysis we have performed with Jason for you to have an idea of which accuracy you can obtain with the service</p>"},{"location":"accuracy/#gnss-geodetic-grade-receiver-static","title":"GNSS geodetic-grade receiver (static)","text":"<p>The purpose of this test was to assess the accuracy that can be achieved using a geodetic grade GNSS receiver and antenna in static mode (non moving platform).</p> Test setup Rover receiver Base station GNSS receiver Septentrio AsteRx Leica GR50 Antenna Septentrio PolaNT Leica AR25 Environment Rooftop, open sky open sky Data length 2.34 hours 24 hours Sampling rate 15 second 30 second Number of epochs 560 2880 GPS start time 2019 Nov 18  12:45:30.000 2019 Nov 18  00:00:00.000 GPS end time 2019 Nov 18  15:05:15.000 2019 Nov 18  23:59:30.000 <p>The test setup (performed at the rooftop of Rokubun's headquarter offices at the MediaTIC building) is shown in the following picture:</p> <p></p> <p>The Septentrio AsteRx data has been processed with Jason with the following main characteristics:</p> Processing characteristics Strategy Post-Processing Kinematic (PPK) Dynamics static Reference station ICGC PLAN (17.4km baseline) <p>In order to assess the results, the same data file (converter to RINEX) has been processed using Canadian Geodetic Survey of Natural Resources Canada Precise Point Positioning (PPP-AR)  tool. The differences are shown in the table below:</p> component NRCAN PPP (final products) Jason PPK difference (vs NRCAN) UTM_X (m) 432640.419 432640.414 -0.005 UTM_Y (m) 4583770.355 4583770.352 -0.003 ellipsoid (m) 92.638 92.561 -0.077* <p>*Please note that we are currently working on fix for JASON so that the antenna models are properly taken in to account, this is expected to substantially close the gap between the NRCAN PPP solution and the JASON PPK.</p>"},{"location":"accuracy/#smartphone-non-moving-dynamic","title":"Smartphone (non-moving dynamic)","text":"<p>This test intends to provide an estimate accuracy of the best accuracy that can be achieved with a smartphone in the most benign environment possible (non moving, open sky)</p> Test setup GNSS receiver Xiaomi Mi 8 Antenna internal Environment Rooftop, open sky Data length 7 minutes Sampling rate 1 second Local time 2019 Nov 19  12:17 <p>The smartphone was colocated on the same point at which the antenna of the static test. The data was then processed with Jason with the following processing strategy:</p> Processing characteristics Strategy Post-Processing Kinematic (PPK) Dynamics Smartphone was not moving, but processed with kinematic stochastics Reference station IGN BCLN (16km baseline) <p></p>"},{"location":"contact/","title":"Contact us","text":"<p>Do not hesitate to contact us if you have questions or need support.</p> <p>Rokubun S.L.  Carrer Llacuna 162-164, 1st floor, suite 102  08018 Barcelona (Spain) </p> <p>phone: +34.935.992.154 e-mail: support@rokubun.cat </p> <p> </p> <p>We will always appreciate any feedback you might have. If you have a couple of minutes, fill-up our user satisfaction survey.</p>"},{"location":"converter/","title":"GNSS converter","text":"<p>If you own an Argonaut or Medea receiver you are probably wondering how to convert the <code>.rok</code> files into something else, or how to extract both the IMU data as well as the time events (if present in the file). Jason provides, free of charge, a converter that does that.</p> <p>First of all login to the service and head towards the GNSS converter  (at the top of the page). You should see the following page:</p> <p></p> <p>Simply drag and drop the file you want to process in the <code>Raw file</code> box and press convert. Once the process is finished, press <code>Download zip</code> to  fetch the data. Assuming that the you uploaded a file named <code>&lt;input_file&gt;</code>, you should see the following files:</p> <ul> <li><code>&lt;input_file&gt;.rnx</code>: The Rinex file (version 3.03) with the GNSS raw measurements recorded by the receiver</li> <li><code>&lt;input_file&gt;.rnx_imu.csv</code>: A columnar file with the IMU data, time tagged in GPS time. See the complete format description here.</li> <li><code>&lt;input_file&gt;.rnx_cam.csv</code>: A columnar file with the event data (e.g. camera event data). See the complete format description here.</li> </ul> <p>Actually, if you have a receiver that ships a ublox receiver, not necessarily our own, you can still use the tool to convert to Rinex file. However we will always deny you can do it ;P</p>"},{"location":"converter/#converted-files","title":"Converted files","text":"<p>This section includes a description of the files delivered by the GNSS converter</p>"},{"location":"converter/#argonaut-gnss-file","title":"Argonaut GNSS file","text":"<p>Rokubun's Argonaut/Medea receivers store GNSS in Ublox format. The output of the GNSS converter in terms of GNSS measurements data will be the equivalent RINEX 3.03 file as follows:</p> <pre><code>     3.03           OBSERVATION DATA    M (MIXED)           RINEX VERSION / TYPE\nRokubun core        rokubun             2019-08-12 15:43:35 PGM / RUN BY / DATE\nUNKN                                                        MARKER NAME\nunknown             unknown                                 OBSERVER / AGENCY\nunknown             unknown             unknown             REC # / TYPE / VERS\nunknown             unknown                                 ANT # / TYPE\n        0.0000        0.0000        0.0000                  APPROX POSITION XYZ\n        0.0000        0.0000        0.0000                  ANTENNA: DELTA H/E/N\n  2019    06    05    01    52   03.7652649                 TIME OF FIRST OBS\nG    4 C1C L1C D1C S1C                                      SYS / # / OBS TYPES\nR    4 C1C L1C D1C S1C                                      SYS / # / OBS TYPES\nE    4 C1C L1C D1C S1C                                      SYS / # / OBS TYPES\n                                                            END OF HEADER\n&gt; 2019 06 05 01 52 20.2019999  0  6\nG05  21643026.31606 113734869.95806     -2084.85906        40.00006\nG13  20940404.71107 110042563.43007       650.48707        45.00007\nG15  21819537.83307 114662444.00207      2552.08207        46.00007\nG29  22272808.61807 117044397.73607     -2139.16707        45.00007\nG30  24262711.51305 127501402.06305      -245.06005        34.00005\nE13  24476988.50208 128627441.38908       970.55808        49.00008\n</code></pre>"},{"location":"converter/#argonaut-imu-file","title":"Argonaut IMU file","text":"<p>Rokubun's Argonaut/Medea receivers store GNSS data as well as IMU data from its inertial sensor. This data is syncrhonized with the GPS time scale and stored in the SD card along with the GNSS raw measurements. When using the conversion tool from Jason, a CSV file with the IMU data will be generated. The file starts with a comment line (starting with <code>#</code>) that describes each column as well as the appropriate units:</p> <ul> <li><code>gps_week</code> The GPS week of the time stamp</li> <li><code>gps_tow</code> The seconds of the GPS week</li> <li><code>mag_x</code>, <code>mag_y</code>, <code>mag_z</code>, 3 components (XYZ) of the magnetometer, expressed in micro-Teslas</li> <li><code>gyro_x</code>, <code>gyro_y</code>, <code>gyro_z</code>, 3 components (XYZ) of the gyroscope, expressed in degrees per second</li> <li><code>accel_x</code>, <code>accel_y</code>, <code>accel_z</code>, 3 components (XYZ) of the accelerometer, expressed in g's (9.81 m/s^2)</li> </ul> <p>All inertial values are referred to the body reference frame. Check the Argonaut/Medea documentation for further details.</p> <p>Example of IMU file:</p> <pre><code># Imu,gps_week,gps_tow[seconds],mag_x[uT],mag_y[uT],mag_z[uT],gyro_x[deg/s],giro_y[deg/s],giro_z[deg/s],accel_x[g],accel_y[g],accel_z[g]\nImu,1990,210938.388921000,-8.400,56.550,-33.600,-2.305,-0.580,0.641,-0.007,0.053,-0.983\nImu,1990,210938.398899000,-9.000,55.800,-31.200,-2.290,-0.641,0.626,-0.015,0.060,-0.980\nImu,1990,210938.408876000,-7.650,53.700,-33.150,-2.275,-0.702,0.626,-0.010,0.053,-0.985\nImu,1990,210938.518632000,-9.750,56.250,-32.250,-2.275,-0.565,0.626,-0.008,0.054,-0.981\nImu,1990,210938.528610000,-9.000,55.800,-33.900,-2.290,-0.504,0.626,-0.007,0.059,-0.979\nImu,1990,210938.538588000,-10.500,55.200,-34.200,-2.275,-0.458,0.641,-0.008,0.057,-0.987\nImu,1990,210938.548566000,-9.000,56.250,-33.600,-2.275,-0.458,0.641,-0.015,0.057,-0.980\nImu,1990,210938.558543000,-7.650,56.250,-33.600,-2.275,-0.473,0.626,-0.013,0.058,-0.988\nImu,1990,210938.593055000,-9.300,55.950,-33.000,-2.305,-0.489,0.641,-0.015,0.059,-0.979\nImu,1990,210938.603033000,-8.550,54.900,-33.450,-2.290,-0.489,0.626,-0.016,0.056,-0.978\nImu,1990,210938.613011000,-9.000,56.850,-33.150,-2.305,-0.550,0.626,-0.012,0.056,-0.982\nImu,1990,210938.622988000,-10.200,55.200,-32.850,-2.305,-0.580,0.626,-0.012,0.059,-0.984\n</code></pre>"},{"location":"converter/#argonaut-cam-file","title":"Argonaut CAM file","text":"<p>In addition, Argonaut/Medea receivers store any time event that has been triggered during the data recording campaign by means of a hot-shoe mounted on a photogrammetry SLR camera or MicaSense. Converting a file that contains time (cam) events will result in the generation of a file with 2 columns: (1) the GPS week and (2) the seconds within the GPS week when the time event took place.</p> <p>The file has as many rows as events detected by the receiver and the time tag is synchronized to the time scale provided by the GNSS receiver.</p> <p>If no cam events have been detected, no file will be generated.</p> <p>Example of CAM (time event) file:</p> <pre><code># Event,gps_week,gps_tow[seconds]\nEvent,1990,211188.789716000\nEvent,1990,211193.854405000\nEvent,1990,211198.683787000\nEvent,1990,211201.679891000\nEvent,1990,211374.665552000\nEvent,1990,211377.808189000\nEvent,1990,211380.612900000\nEvent,1990,211383.346676000\nEvent,1990,211385.930332000\n</code></pre>"},{"location":"converter/#third-party-options","title":"Third party options","text":"<p>If you'd rather convert the files yourself without using our platform, you just have to know that any tool that is able to parse ublox binary format (<code>ubx</code>) will convert your files into Rinex format. Two examples are UNAVCO's <code>teqc</code> and RTKLIB's <code>convbin</code> (or its Windows GUI equivalent <code>rtkconv</code>). </p> <p>The resource section of this documentation contains links on how to obtain them. Note however, that you will have to download these tools yourself or, if you are familiar with Docker, we compiled an image (rokubun/gnss_tools) with these tools included (and much more).</p> <p>For the examples given in the following sections, you will need the sample <code>rok</code> file argonaut_cam.rok.</p>"},{"location":"converter/#teqc","title":"teqc","text":"<p>To convert the <code>rok</code> file into Rinex 2 (adding some header fields), use the following command:</p> <pre><code>marker_name=\"ARGO\"\nrx_type=\"argonaut\"\nant_type=\"internal/patch\"\nteqc  -ublox ubx -O.rt ${rx_type} -O.at ${ant_type} -O.mo ${marker_name} argonaut_cam.rok &gt; argo0580.18o\n</code></pre>"},{"location":"converter/#convbin","title":"convbin","text":"<p>If you'r rather use <code>convbin</code>, please use this command (to output the data in Rinex 3.03 format):</p> <pre><code>marker_name=\"ARGO\"\nrx_number=\"03018-1-0xxx\"\nrx_type=\"argonaut\"\nant_type=\"internal/patch\"\nconvbin -v 3.03 -od -os -r ubx -o  argo0580.18o -hr \"${rx_number}/${rx_type}/\" -ha \"/${ant_type}\" -hm ${marker_name} argonaut_cam.rok\n</code></pre>"},{"location":"examples/","title":"Usage examples","text":"<p>This section includes several usage examples that cover most of the use cases that Jason could support. Go to the quick start guide for a n example of a basic usage with a single rover file.</p> <p>This section will use the term rover instead of receiver in order to distinguish it from a reference receiver (or base receiver), which is usually static and is used to provide corrections to the (usually) moving (roving) receiver.</p>"},{"location":"examples/#rover-and-base-files","title":"Rover and base files","text":"<p>If the area you are surveying does not have a nearby CORS station, you can use your own reference GNSS receiver. During the campaign make sure you collect data at the same time as your rover and then process the rover GNSS data together with the GNSS data from the base station.</p> <p>To execute this example, follow these steps:</p> <p>1- Download one or several of the test datasets listed below</p> Use case description Rover file Base station file Event file DJI Phantom 4 RTK drone [<code>*</code>] Rover Base station events file Topodrone on a Mavic 2 Pro Rover Base station Within rover file Rokbun's ARGONAUT on a drone Rover No base station Within rover file Septentrio Mosaic X5 driving Rover Base station No events <p>[<code>*</code>] Courtesy of Terradroneology</p> <p>2- Log in with your account and Jason and go to the \"GNSS processor\" tab.</p> <p>3- Drag-and-drop the two downloaded files at the rover and base station boxes, as shown below.</p> <p></p> <p>4- Press \"Process file\" and wait for the process to finish. The rest of the steps are the same as those of the quick start guide.</p> <p>An important note to consider is regarding the base station coordinates. If the input file is in Rinex format and you are confident that the coordinates of the <code>APPROX POSITION XYZ</code> header field are accurate, you do not need to do anything else. However, you can indicate a proper set of coordinates for the base station in the field \"External base station position (optional)\" in the form of latitude, longitude and height. Latitude and longitude shall be expressed in meters while the height should be expressed in height above the ellipsoid.</p> <p>Also note that the formats supported by the base station are the same as the  ones supported by the rover receiver.</p>"},{"location":"examples/#processing-smartphone-data","title":"Processing smartphone data","text":"<p>One of the features of Jason is the ability to process GNSS raw measurements logged by smartphones. To do this, you can record such data using various alternatives:</p> <ul> <li>Store RINEX data using an app (from e.g. Geo++ or NSL)</li> <li>Store raw measurements using Google's GNSS logger </li> </ul> <p>We recommend the usage of Google's app as Jason can directly ingest the files generated by it. Just start the app and make sure that both the Location and Measurements switches are turned on (see left panel of lower figure). Then head towards the LOG tab and click START LOG (at the bottom of the screen). This will start recording the measurements.</p> Main GNSS logger page Log tab <p>Once the data take is finished, you will have a <code>gnss_log_&lt;date&gt;.txt</code> file in your smartphone (usually under the folder <code>gnss_log</code>). To process this file you have 2 options:</p> <ul> <li>Directly from the smartphone: open the smartphone browser and go to the   Jason web page. Head over \"GNSS processor\" and select the file you want   to process, the smartphone will open then the app to browse the files you   have in your device. You will be able then to select and upload the file.</li> <li>From a desktop computer: transfer the file to your computer and follow the   process described in the quickstart</li> </ul> <p>As a bonus, Jason will also deliver, besides the usual files, the Rinex files that resulted from the conversion of the GNSS logger data.</p>"},{"location":"examples/#static-receiver-rtcm-3-format","title":"Static receiver, RTCM 3 format","text":"<p>The use case for this example is in the event that you deploy a base station so that it transmits the data via NTRIP to an NTRIP caster. Rover receivers can then connect to this caster but need the precise coordinates of this base station, so you use Jason to get those precise coordinates. station.</p> <p>Once the base station is serving data to the NTRIP caster, the operator can record data into <code>rtcm3</code> format using e.g. rtklib's <code>str2str</code> tool. After you log in into Jason, send the data, as shown in the following figure (for a data file <code>bcln0.rtcm3</code>)</p> <p></p> <p>One point to take into account is the fact that the file conversion within Jason does not allow the user to specify the approximate date of the file. Therefore, unless the RTCM3 file is recent (within the same GPS week), the RTCM3 file will not he processed. Therefore, the recommended approach would be to convert the rtcm3 file into Rinex and then upload it to the service. If you use <code>rtklib</code>'s <code>convbin</code> tool, you can launch the command:</p> <pre><code>convbin -r rtcm3 -v 3.03 -f 3 -scan -o bcln0.rinex bcln0.rtcm3\n</code></pre> <p>Then upload the file <code>bcln0.rinex</code> to Jason.</p> <p>You will get this station precise coordinates that can be further used by rovers using this station in the NTRIP caster.</p>"},{"location":"manual/","title":"Manual","text":""},{"location":"manual/#processing-engine","title":"Processing engine","text":"<p>Under the hood, Jason runs the open-source package rtklib as the positioning engine, whilst Rokubun positioning engine is getting ready for deployment. This service works on a best-effort basis, and attempts to run these processing strategies in the following prioritized order:</p> <ul> <li>Post Processed Kinematic (PPK), Jason computes a coarse estimate of the rover position using SPP in   order to have a rough estimate of the receiver position and be able to   automatically select the closest base station from the set of   stations continuously monitored by Jason.   If a nearby station is found (less than a certain baseline),   then the corresponding RINEX data is downloaded in order to perform differential   positioning. Alike, if you provide Jason with a base station measurements file, it will undergo PPK technique processing.</li> <li>Precise Point Positioning (PPP), if no nearby base station is found, Jason will attempt PPP if the precise   orbits and clocks for the day to be processed are found and the input data   is multi-frequency.</li> <li>Single Point Positioning (SPP), if PPP failed, the data processed using the broadcast orbits and    clocks will be delivered.</li> </ul>"},{"location":"manual/#supported-formats","title":"Supported formats","text":"<p>Jason supports the following input formats to input GNSS observables (pseudorange, carrier-phases, ...):</p> <ul> <li>Rinex 2/3</li> <li>ublox formats (both single and multiple frequency formats). Data from chipsets   such as NEO-M8T or ZED-F9P are supported. This obviously cover also all GNSS   receivers that use these chipsets (e.g. Drotek, EMLID receivers, ArduSimple, ...)</li> <li>Data from Rokubun's receivers (Argonaut and Medea, which are Ublox-based, but   also adding IMU and Event data)</li> <li>Google's Android GNSS logger (smartphone data)</li> <li>GPS Test app (smartphone data)</li> <li>GalileoPVT app (smartphone data)</li> <li>RTCM 3 data</li> <li>Septentrio binary (SBF) files</li> </ul>"},{"location":"manual/#api","title":"API","text":"<p>For workflows that require to process several GNSS files in batch, Jason provides an Application Programming Interface (API) that allows to automate the complete processing or to include the positioning estimation step in your application pipeline (for example automated photogrammetry software).</p> <p>In fact, Jason is fully implemented as an API and the front-end simply uses it. The API allows that you to e.g. program tasks in Jason using URLs via the command line of your Operating System or create plugins.</p> <p>The full Swagger documentation of the API can be accessed here.</p> <p>For Android devices you can see how it's used in the  GithHub repository.</p>"},{"location":"manual/#launching-a-process","title":"Launching a process","text":"<p>Let' assume you have a GNSS data file in RINEX format named <code>GARR2150.15o</code> that you wish to process. Let's also assume you have your API key and secret token ready (fetch them in your user section):</p> <p>``` bash tab=\"Bash\" export APIKEY=\"jason_api_key_here\" export SECRET_TOKEN=\"your_secret_token_here\"</p> <p>file=\"GARR2150.15o\" url=\"https://api.jason.rokubun.cat/api/processes/\"</p> <p>curl -X POST  -H \"accept: application/json\" \\                        -H \"Content-Type: multipart/form-data\" \\                        -H \"ApiKey: ${APIKEY}\"  \\                        -F  token=${SECRET_TOKEN} -F type=GNSS  \\                        -F \"rover_file=@s${file}\" ${url} <pre><code>```py3 tab=\"Python\"\nimport requests\n\nAPIKEY=\"jason_api_key_here\"\nSECRET_TOKEN=\"your_secret_token_here\"\n\nfile = 'GARR2150.15o'\nurl='https://api.jason.rokubun.cat/api/processes'\n\nheaders = {\n    'accept': 'application/json',\n    'ApiKey': APIKEY,\n}\n\nfiles = {\n    'type' : (None, \"GNSS\"),\n    'token' : (None, SECRET_TOKEN),\n    'rover_file': (file, open(file, 'rb'))\n}\n\nr = requests.post(url, headers=headers, files=files)\n</code></pre></p> <p>```java tab=\"Android\"   Context context;   JasonClient jasonClient = JasonClient.getInstance(context);   ProcessInformation processInformation;   // You should perform login before submiting a process with username and password   jasonClient.loging(username, password);   // Or you can login by settign the token    jasonCLient.login(token)   Single submitProcess = jasonClient.submitProcess(type, roverFile);   submitProcess.map(process -&gt; processInformation = new ProcessInformation(process.getMessage(), process.getId())) <pre><code>Now the process is being run in Rokubun's servers. The previous command replies\nwith a small JSON formatted string with the status of the command (success\nindicates that the process has been correctly launched) and the process id that\nhas been assigned (in this example the process id is 707):\n\n```json\n{\"message\":\"success\",\"id\":707} \n</code></pre> <p>You can check the status of the process at any time under the tab My processes in your user area of the front-end or, alternatively with this curl command (that will answer with a JSON string):</p> <p>```bash tab=\"Bash\"</p> <p>process_id=\"707\" url=\"https://api.jason.rokubun.cat/api/processes/${process_id}\"</p> <p>curl -X GET -H \"ApiKey: ${APIKEY}\" \\                      -H \"accept: application/json\" \"${url}?token=${SECRET_TOKEN}\" <pre><code>```py3 tab=\"Python\"\nimport requests\n\nprocess_id=3145\n\nurl='https://api.jason.rokubun.cat/api/processes/{}'.format(process_id)\n\nheaders = {\n    'accept': 'application/json',\n    'ApiKey': APIKEY\n}\n\nr = requests.get(url, headers=headers, params={ 'token' : SECRET_TOKEN })\n</code></pre></p> <p>```java tab=\"Android\"   Context context;   JasonClient jasonClient = JasonClient.getInstance(context);</p> <p>String processId=3145   Long maxTimeoutMillis = 60000L   ProcessStatus processStatus;</p> <p>Observable processStatus =  jasonClient.getProcessStatus(processId, maxTimeoutMillis)  <p>processStatus.map(process -&gt; processStatus = new ProcessStatus(process.processLog, process.processResult))</p> <p>// When process is finished you can get a specific result   processStatus.processResult.getSppKmlUrl()   processStatus.processResult.getPreciseCsvUrl()   ...   // Or can download results file   processStatus.processResult.getZipUrl()</p> <pre><code>The JSON string will give details on the run as well as any log messages that\ndescribe what is being done with the file (PPK, PPP, SPP, ... depending on the\ndata availability). A sample is shown below:\n\n```json\n{\n  \"process\": {\n    \"id\": 707,\n    \"user_id\": 24,\n    \"type\": \"GNSS\",\n    \"status\": \"RUNNING\",\n    \"source_file\": \"https://argonaut-files.s3.eu-central-1.amazonaws.com/source_files/258ab2a88691ad7cb47d91a832e13aa8/GARR2150.15o\",\n    \"source_base_file\": null,\n    \"camera_metadata_file\": null,\n    \"created\": \"2018-02-07 14:33:38\",\n    \"finished\": null\n  },\n  \"log\": [\n    {\n      \"id\": 1630,\n      \"process_id\": 707,\n      \"level\": \"INFO\",\n      \"message\": \"[GARR2150.15o] file successfully loaded\\n\",\n      \"created\": \"2018-02-07 14:33:42\"\n    },\n    {\n      \"id\": 1631,\n      \"process_id\": 707,\n      \"level\": \"INFO\",\n      \"message\": \"[Broadcast] orbits successfully downloaded\\n\",\n      \"created\": \"2018-02-07 14:33:45\"\n    },\n    ...  \n</code></pre>"},{"location":"manual/#downloading-the-results-file","title":"Downloading the results file","text":"<p>Once the status of the process is finished (<code>\"status\": \"FINISHED\"</code>, under <code>\"process\"</code>), the JSON response generated by the previous command will contain, at the end, the link to the zipped result file with the result of the process:</p> <pre><code>    ...\n{\n\"id\": 2043,\n\"process_id\": 707,\n\"url\": \"https://argonaut-files.s3.eu-central-1.amazonaws.com/results/1589edb715ebbe117bbdefe5e44192e2/results.zip\",\n\"created\": \"2018-02-07 14:34:28\",\n\"name\": \"results.zip\",\n\"extension\": \"zip\"\n}\n]\n}\n</code></pre> <p>You can download the results file via the browser, using Android version or, if you want to automate  the process, use Bash scripting, like so:</p> <pre><code>wget `json2yaml response.json  | awk '/url/&amp;&amp;/results.zip/{print $2}'`\n</code></pre> <p>(note that you will need the tool json2yaml for that to work)</p> <p>You can also use Python to automate this and download the results file (<code>results.zip</code>):</p> <p>``` py3 tab=\"Python\" import json import urllib.request</p> <p>with open(\"response.json\") as fp:    res = json.load(fp)</p> <p>url = res[\"results\"][-1][\"url\"] urllib.request.urlretrieve(url) <pre><code>## Result files\n\nThis section include the information of the various file formats delivered by\nJason.\n\n### GNSS processor files\n\nWhen a process has been successful, a compressed (ZIP) file is generated with all the\nresults of the process. The format of the different files included in the bundle\nby the GNSS processor are described in the following sub-sections.\n\n#### Position files (csv)\n\nPositions will be delivered as a comma separated file where the first line is\na comment (starts with `#`) with a description of the fields, which are:\n\n- columns 1-2: **Epoch** of the solution, expressed as GPS week and seconds within the GPS week.\n- columns 3-5: **Position** longitude and latitude expressed in decimal degrees and height in\n                meters above the ellipsoid.\n- columns 6-8: Standard deviation in meters of the North, East and Up components.\n                Note that these values are the formal **errors** delivered by the\n                position filter (i.e. square root of the postfit variances) and\n                they do not necessarily reflect the actual error in the\n                navigation solution. The surveyor will need an external reference\n                to compute the actual error. However, these values can be\n                treated as a preliminary quality metrics of the solution.\n\nJason will always deliver the position file corresponding to the SPP\nstrategy (files ending with `_spp.csv`). If a more accurate strategy\n(PPP or PPK) could be performed, additional CSV will be also delivered,\nending with either `_ppp.csv` or `_ppk.csv`, to indicate the strategy\nof the solution.\n\nExample:\n\n```csv\n# GPSW,GPSSoW,latitude(deg),longitude(deg),height(m),sdn(m),sde(m),sdu(m)\n2069,124585.300000,41.3495230130,1.6680445200,246.06570,2.3403,1.5631,4.6059\n2069,124585.400000,41.3495233800,1.6680436110,246.40920,2.3403,1.5631,4.6059\n2069,124585.500000,41.3495239180,1.6680507170,246.51000,2.3403,1.5631,4.6058\n2069,124585.600000,41.3495241180,1.6680519850,246.22500,2.3403,1.5631,4.6058\n2069,124585.700000,41.3495263560,1.6680520780,246.36660,2.3403,1.5631,4.6058\n2069,124585.800000,41.3495281560,1.6680502930,245.82960,2.3404,1.5631,4.6058\n2069,124585.900000,41.3495297610,1.6680474000,245.42580,2.3404,1.5631,4.6058\n</code></pre></p>"},{"location":"manual/#position-files-kml","title":"Position files (kml)","text":"<p>For convenience, the positions are converted to KML format and included in the ZIP package as well. These files can be easily opened using tools such as Google Earth, just double-click on the files and the application will open the file.</p> <p>Similarly to the case of the CSV files, the KML corresponding to the SPP strategy will be always delivered. If PPP or PPK has been successful, the KML files for this strategy will be also delivered. The strategy will be part of the file name.</p> <p>In addition, for quick visualization, a decimated version of the KML file is also provided. This is useful for a quick preview of files that have been  taken in long data campaigns.</p> <p>In case of static receivers, only the last point of the processing will be included in the KML file.</p>"},{"location":"manual/#plots-png","title":"Plots (png)","text":"<p>As a visual summary of the processing task, a series of plots (in PNG format) are also included in the bundle. These files are:</p> <ul> <li><code>height.png</code>: Time series of the height above the ellipsoid (in meters).</li> <li><code>skyplot.png</code>: Skyplot showing the distribution of the satellites that have                  been used for the processing. The points in the plot have                  different color coding, depending on the constellation. Also,                  the satellite ID is also shown at the last point, which is a                  helper to know the direction to which the satellite moved.</li> <li><code>num_satellites.png</code>: The time series of the number of satellite during the                 processing. The same color coding used in the skyplot has been                 used here. The chart is a stack plot and shows the number of                 satellites, at each epoch, of each constellation.</li> </ul>"},{"location":"manual/#timecamera-events-csv","title":"Time/Camera events (csv)","text":"<p>In the event that the input contained time events (usually generated from camera trigger), the output package will also contain a camera event file <code>camera_events.csv</code>. The file contains as many rows as time triggers (camera events) detected in the input file. Each row of the file contains the time tag, position and formal error of the camera event, with the same format as  described above for the Position CSV files.</p>"},{"location":"manual/#user-section","title":"User section","text":"<p>In order to go to your user area, point to the top-right part of the page,  where your e-mail address is displayed, and click on the arrow. A drop-down menu will be displayed. Then click \"My Account\" as shown in the screenshot below.</p> <p></p> <p>In your account you will find 3 areas:</p> <ul> <li>Profile where you will be able to set your Name and e-mail address.</li> <li>Change password, to reset your password.</li> <li>Software, where you will be able to fetch your API key, as shown below.</li> </ul>"},{"location":"manual/#how-to-obtain-your-api-key","title":"How to obtain your API key","text":"<p>In order to use the PaaS API, you will need both the API key and your secret user token. While the API key identifies our PaaS and is common across all users, the secret token is your ID and will link each process you request with your account.</p> <p>Once in your area, click on the Software tab. In this tab you will find both the API key and secret token that you need.</p> <p></p>"},{"location":"otherhardware/","title":"Why the file I uploaded is not processing within JASON engine?","text":"<p>JASON engine requires GNSS raw data to be able to extract the satellite ranging information in which precise positioning is based, this means that your rover receiver must be correctly configured or otherwise JASON will not be able to find the minimum required information.</p> <p>For example, if you want to upload u-blox data you must ensure that your file, at the very least, contains UBX-RXM-RAWX packets, if you are uploading Septentrio data then you must ensure that your file contains MeasEpoch or Meas3Ranges packets.</p>"},{"location":"quickstart/","title":"Quick start guide","text":"<p>This section is intended for those who cannot wait out there  and are eager to process a file right away. In this guide you will learn:</p> <ul> <li>How to use Jason to perform a PPK process using a single   GNSS binary file obtained from a Ublox receiver.</li> <li>View and download results file</li> </ul> <p>This example is the most simple processing case, which turns to be also the most common processing type performed by our users. You will not need any base station for this tutorial, just follow these steps:</p> <ol> <li>Go to the Jason web page and register. You will   need to specify an e-mail and a password. Once you click \"Sign up\", you should   receive an e-mail with a verification link.</li> <li>Download the test file, which has been taken with a DJI Mavic 2 Pro equiped with a Topodrone PPK system   and contains GNSS raw measurements and camera events.</li> <li>Log in with your credentials into Jason and go to \"GNSS Processor\"   (should be the default page after logging in).</li> <li>Drag-and-drop the downloaded file into the \"Rover GNSS data file\" box. Alternatively,   you can click the box \"Select file\" and a file explorer window will pop-up.</li> </ol> <p></p> <ol> <li>Press \"Process file\". The file will be uploaded and the processing will start,    the front-end will issue several progress logs to inform about the strategy    used and status. When the process is Finished, a button will appear at the     bottom of the page.</li> </ol> <p></p> <ol> <li>Click \"View Results\" to access the results page, which contains    a map window to show a preview of the results. The map contains both the    track in SPP and PPP/PPK (if the service could apply one of these processing strategies)    and also all the camera events (if present in the input file) represented    as red crosses. The result page also contains 3 images with the satellite    view, number of satellites as well as height profile (above the ellipsoid).    Note that for static positioning, only one point will be plot in the map,    and thus no height profile will be shown.</li> </ol> <p></p> <ol> <li>You can access the log messages if you click the \"View Log\" box at the top    of the page and \"Download results\" as a ZIP format. The contents of the    file are described in the file format section of this documentation.</li> </ol>"},{"location":"resources/","title":"Resources","text":"<p>This section includes a list of resources related to GNSS data that you might find useful, should you require further information.</p>"},{"location":"resources/#glossary","title":"Glossary","text":"term definition broadcast ephemeris is the set of data delivered by the GNSS satellite such as satellite orbits and clocks that are required to compute the position convergence time time that the navigation filter needs to reach a target accuracy in the position solution formal error error estimate of the navigation filter GNSS raw measurements The set of measurements (pseudorange and carrier phase) generated by a GNSS receiver, used to compute the navigation solution navigation filter is the mathematical engine that implements a given strategy in order to estimate the"},{"location":"resources/#external-links","title":"External links","text":"<p>There is a list of external links and references you might find handy:</p> <ul> <li>ESA's Navipedia page.</li> <li>UPC's gAGE Course on GNSS data processing</li> <li>GPS service daemon software gpsd</li> <li>RTKlib, an open-source GNSS data processing software</li> <li>UNAVCO's teqc Rinex pre-processing tool</li> </ul> <p>We'd rather have you using our service to compute position, but should you want to explore other services, here there is a list of them, that perform PPP, in case you want to try them out:</p> <ul> <li>JPL's Automatic Precise Positioning Service</li> <li>NRCan's PPP service</li> <li>Geoscience Australia positioning service</li> <li>GMV's magicGNSS service</li> <li>Trimble CenterPoint RTX Post-processing service</li> </ul>"},{"location":"strategies/","title":"GNSS data processing strategies","text":"<p>There are multiple strategies to process GNSS raw measurements in order to obtain the position. The most common ones are:</p> <ul> <li>Single Point Positioning (SPP)</li> <li>Precise Point Positioning (PPP)</li> <li>Real Time Kinematics (RTK)</li> <li>Post-processing Kinematics (PPK)</li> </ul> <p>With the advent of new constellations and the inflationary number of additional signals and frequencies (between the original L1 and L2 from GPS) as well as the requirements of convergence time in dynamic scenarios, new techniques based on innovative data models (such as undifferenced and uncombined processing) or a combination of classic techniques (PPP-RTK) are gaining relevance in front of these.</p> \u00a0strategy needs base? uses carrier-phase? orbits &amp; clocks accuracy SPP no no broadcast &lt; 5 m PPP no yes precise cm (multi-freq), dm (single-freq) RTK yes yes broadcast cm (multi-freq), dm (single-freq) PPK yes yes broadcast cm (multi-freq), dm (single-freq) <ul> <li>needs base? implies if the technique is a differential technique (requires   the provision of GNSS data from a base station with known coordinates)</li> <li>uses carrier-phase? the carrier-phase is required to achieve decimeter or   centimeter accuracy.</li> <li>orbits &amp; clocks which type of orbit and clock products does the technique   require.</li> <li>accuracy is a ballpark indicator of the accuracy that can be achieved for   the strategy.</li> </ul> <p>Besides the technique to process data itself, one can inform the filter wether the rover moves (dynamic) or stays still (static). This can be configured in Jason: select only static if you are sure the receiver was not moving during the data campaign, otherwise leave the default, which assumes a moving (dynamic) rover.</p> <p>Finally, please consider that the number of frequencies tracked by the receiver might be crucial in terms of performance. For standalone techniques (SPP, PPP), which  do not require base station, tracking 2 or more frequencies will allow to remove the ionosphere error, leading to greater accuracies. In general however, and this is valid for all strategies, tracking multiple frequencies will provide not only better accuracies but also increased level of robustness and faster convergence times.</p>"}]}